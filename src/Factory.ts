import merge from "deepmerge";
import has from "lodash.has";
import set from "lodash.set";
import unset from "lodash.unset";

export class Factory<T extends object = Record<string, any>> {
  /**
   * Original, unaltered schema.
   *
   * @remarks
   * This property stores the very first schema provided during initialisation. It ensures that we always retain a copy
   * of the initial data payload, allowing us to reference and reset the target as needed.
   */
  private readonly source: T;

  /**
   * Target data schema.
   *
   * @remarks
   * The target schema that serves as the basis for all responses generated by the factory. This property represents
   * the primary entity subject to changes within this factory instance.
   */
  private target: T;

  /**
   * Initialise the Factory.
   *
   * @param schema - The schema for the Factory.
   *
   * @remarks
   * The constructor creates shallow copies of the schema to ensure that changes made within the Factory do not affect
   * the original object.
   */
  public constructor(schema: T) {
    this.source = { ...schema };
    this.target = { ...schema };
  }

  /*
   * ------------------------------------------------------------------------------------------
   * Modifiers
   * ------------------------------------------------------------------------------------------
   * The following method(s) are responsible for modifying the target schema, which will
   * ultimately be returned to the consumer. All modifiers return this factory instance for
   * chaining purposes.
   * ------------------------------------------------------------------------------------------
   */

  /**
   * Append a key-value pair to the target schema, using optional dot notation for nested keys.
   *
   * @param key - The name of the key to append to the schema. You can use dot notation for nested keys.
   * @param value - The value of the key to append to the schema.
   *
   * @remarks
   * This method allows the addition of key-value pairs of any type to the target schema. Factoryse is primarily used
   * for testing, and users may want to test scenarios with invalid keys and/or values, so we do not restrict to the T
   * type interface. It's important to throw an error if the key already exists to prevent accidental overwrites,
   * ensuring test stability.
   */
  public add(key: string, value: any): Pick<this, "get" | "modify" | "remove" | "assign"> {
    if (has(this.target, key)) {
      throw new Error(`The key '${key}' already exists in the factory. To update this value, please use the 'modify()' method.`);
    }
    set<T>(this.target, key, value);
    return this;
  }

  /**
   * Update a value in the target schema, using optional dot notation for nested keys.
   *
   * @param key - The name of the key to update in the schema. You can use dot notation for nested keys.
   * @param value - The value to update for the key in the schema.
   *
   * @remarks
   * This method allows the modification of a value of any type for a key in the target schema. Factoryse is primarily
   * used for testing, and users may want to test scenarios with invalid keys and/or values, so we do not restrict to
   * the T type interface. It's essential to throw an error if the key doesn't exist to prevent accidental updates,
   * ensuring the stability of tests.
   */
  public modify(key: string, value: any): Pick<this, "get" | "add" | "remove" | "assign"> {
    if (!has(this.target, key)) {
      throw new Error(`The key '${key}' does not exist in the factory. To add this value, please use the 'add()' method.`);
    }
    set<T>(this.target, key, value);
    return this;
  }

  /**
   * Remove a key from the target schema, using optional dot notation for nested keys.
   *
   * @param key - The name of the key to remove from the schema. You can use dot notation for nested keys.
   *
   * @remarks
   * This method allows the deletion of a key with any name from the target schema. Factoryse is primarily used for
   * testing, and users may want to test scenarios with invalid keys and/or values, so we do not restrict to the T type
   * interface. It's crucial to throw an error if the key doesn't exist to prevent accidental removals, ensuring the
   * stability of tests.
   */
  public remove(key: string): Pick<this, "get" | "add" | "modify" | "assign"> {
    if (!has(this.target, key)) {
      throw new Error(`The key '${key}' does not exist in the factory. To add this value, please use the 'add()' method.`);
    }
    unset(this.target, key);
    return this;
  }

  /**
   * Assigns a new source schema to the target and merges them.
   *
   * @param source - The source schema to assign to the target.
   * @param mergeArrays - Determines whether to merge arrays (true) or overwrite them with the source schema (false).
   *
   * @remarks
   * This method merges the source schema into the target schema. The source schema takes precedence in the merge and
   * will overwrite any values of the same key in the target schema
   */
  public assign(source: Factoryse.PartialDeep<Factoryse.Extendable<T>>, mergeArrays = false): Pick<this, "get" | "add" | "modify" | "remove"> {
    this.target = merge<T>(this.target, source as T, {
      arrayMerge: mergeArrays ? undefined : (destination, source: unknown[]) => source,
    });
    return this;
  }

  /**
   * Reset the target schema to match the source schema.
   *
   * @remarks
   * This method effectively reverts any changes made to the target schema since its initialisation, restoring it to its
   * original state as defined by the source schema. This action is irreversible and will permanently erase all
   * modifications.
   */
  public reset(): Pick<this, "get" | "add" | "modify" | "remove"> {
    this.target = this.source;
    return this;
  }

  /*
   * ------------------------------------------------------------------------------------------
   * Getters
   * ------------------------------------------------------------------------------------------
   * The method(s) below are responsible for providing the Factory data schema to the consumer.
   * Each of these methods returns the schema themself, not the instance of this factory.
   * ------------------------------------------------------------------------------------------
   */

  /**
   * Retrieve the resulting schema.
   *
   * @remarks
   * This method returns the modified target schema after all modifications have been applied. The schema includes all
   * keys defined in the original type `T`, and it can also include additional key-value pairs with string keys of any
   * type added during runtime.
   */
  public get(): Factoryse.Extendable<T> {
    return this.target as Factoryse.Extendable<T>;
  }
}
